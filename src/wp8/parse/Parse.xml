<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parse</name>
    </assembly>
    <members>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.AuthenticateAsync(System.Threading.CancellationToken)">
            <summary>
            Authenticates with the service.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.Deauthenticate">
            <summary>
            Deauthenticates (logs out) the user associated with this provider. This
            call may block.
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseAuthenticationProvider.RestoreAuthentication(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Restores authentication that has been serialized, such as session keys,
            etc.
            </summary>
            <param name="authData">The auth data for the provider. This value may be null
            when unlinking an account.</param>
            <returns><c>true</c> iff the authData was successfully synchronized. A <c>false</c> return
            value indicates that the user should no longer be associated because of bad auth
            data.</returns>
        </member>
        <member name="P:Parse.Internal.IParseAuthenticationProvider.AuthType">
            <summary>
            Provides a unique name for the type of authentication the provider does.
            For example, the FacebookAuthenticationProvider would return "facebook".
            </summary>
        </member>
        <member name="M:Parse.Internal.FacebookAuthenticationProvider.TryParseOAuthCallbackUrl(System.Uri,System.Collections.Generic.IDictionary{System.String,System.String}@)">
            <summary>
            Parses a uri, looking for a base uri that represents facebook login completion, and then
            converting the query string into a dictionary of key-value pairs. (e.g. access_token)
            </summary>
        </member>
        <member name="T:Parse.Internal.FlexibleDictionaryWrapper`2">
            <summary>
            Provides a Dictionary implementation that can delegate to any other
            dictionary, regardless of its value type.  Used for coercion of
            dictionaries when returning them to users.
            </summary>
            <typeparam name="TOut">The resulting type of value in the dictionary.</typeparam>
            <typeparam name="TIn">The original type of value in the dictionary.</typeparam>
        </member>
        <member name="T:Parse.Internal.FlexibleListWrapper`2">
            <summary>
            Provides a List implementation that can delegate to any other
            list, regardless of its value type.  Used for coercion of
            lists when returning them to users.
            </summary>
            <typeparam name="TOut">The resulting type of value in the list.</typeparam>
            <typeparam name="TIn">The original type of value in the list.</typeparam>
        </member>
        <member name="T:Parse.Internal.IdentityEqualityComparer`1">
            <summary>
            An equality comparer that uses the object identity (i.e. ReferenceEquals)
            rather than .Equals, allowing identity to be used for checking equality in
            ISets and IDictionaries.
            </summary>
        </member>
        <member name="T:Parse.Internal.InternalExtensions">
            <summary>
            Provides helper methods that allow us to use terser code elsewhere.
            </summary>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.Safe``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Ensures a task (even null) is awaitable.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.Safe(System.Threading.Tasks.Task)">
            <summary>
            Ensures a task (even null) is awaitable.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.GetPartial``1(Parse.ParseObject,Parse.Internal.InternalExtensions.PartialAccessor{``0})">
            <summary>
            Partial methods cannot return a value, so we instead make partial accessors
            use ref params. This helper can be used to write code more normally so we get
            the out-param or default when calling a partial method. Given a partial method:
            partial void GetFoo(ref string foo)
            we can say string foo = this.GetPartial&lt;string&gt;(GetFoo);
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="action"></param>
        </member>
        <member name="M:Parse.Internal.InternalExtensions.PartialAsync``1(System.Object,Parse.Internal.InternalExtensions.PartialAccessor{System.Threading.Tasks.Task{``0}})">
            <summary>
            Partial methods cannot return a value, so we instead make partial accessors
            use ref params. This means you cannot effectively make a partial which is
            async. This code helps create a design pattern where a partial takes a ref Task
            param and we can await the PartialAsync of it. Given a partial method:
            partial void FooAsync(ref Task&lt;string&gt; task)
            we can say string foo = await PartialAsync&lt;string&gt;(FooAsync);
            </summary>
            <typeparam name="T"></typeparam>
            <param name="self"></param>
            <param name="partial"></param>
            <returns></returns>
        </member>
        <member name="T:Parse.Internal.IParseFieldOperation">
            <summary>
            A ParseFieldOperation represents a modification to a value in a ParseObject.
            For example, setting, deleting, or incrementing a value are all different kinds of
            ParseFieldOperations.  ParseFieldOperations themselves can be considered to be
            immutable.
            </summary>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.Encode">
            <summary>
            Converts the ParseFieldOperation to a data structure that can be converted to JSON and sent to
            Parse as part of a save operation.
            </summary>
            <returns>An object to be JSONified.</returns>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.MergeWithPrevious(Parse.Internal.IParseFieldOperation)">
            <summary>
            Returns a field operation that is composed of a previous operation followed by
            this operation. This will not mutate either operation. However, it may return
            <code>this</code> if the current operation is not affected by previous changes.
            For example:
              {increment by 2}.MergeWithPrevious({set to 5})       -> {set to 7}
                    {set to 5}.MergeWithPrevious({increment by 2}) -> {set to 5}
                   {add "foo"}.MergeWithPrevious({delete})         -> {set to ["foo"]}
                      {delete}.MergeWithPrevious({add "foo"})      -> {delete}        /// </summary>
            <param name="previous">The most recent operation on the field, or null if none.</param>
            <returns>A new ParseFieldOperation or this.</returns>
        </member>
        <member name="M:Parse.Internal.IParseFieldOperation.Apply(System.Object,Parse.ParseObject,System.String)">
            <summary>
            Returns a new estimated value based on a previous value and this operation.  This
            value is not intended to be sent to Parse, but it is used locally on the client to
            inspect the most likely current value for a field.
            
            The key and object are used solely for ParseRelation to be able to construct objects
            that refer back to their parents.
            </summary>
            <param name="oldValue">The previous value for the field.</param>
            <param name="obj">The object that contains this value.</param>
            <param name="key">The key that this value is for.</param>
            <returns>The new value for the field.</returns>
        </member>
        <member name="T:Parse.Internal.Json">
            <summary>
            A simple recursive-descent JSON Parser based on the grammar defined at http://www.json.org
            and http://tools.ietf.org/html/rfc4627
            </summary>
        </member>
        <member name="F:Parse.Internal.Json.startOfString">
            <summary>
            Place at the start of a regex to force the match to begin wherever the search starts (i.e.
            anchored at the index of the first character of the search, even when that search starts
            in the middle of the string).
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Parse(System.String)">
            <summary>
            Parses a JSON-text as defined in http://tools.ietf.org/html/rfc4627, returning an
            IDictionary&lt;string, object&gt; or an IList&lt;object&gt; depending on whether
            the value was an array or dictionary. Nested objects also match these types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Encodes a dictionary into a JSON string. Suppots values that are
            IDictionary&lt;string, object&gt;, IList&lt;object&gt;, strings,
            nulls, and any of the primitive types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Collections.Generic.IList{System.Object})">
            <summary>
            Encodes a list into a JSON string. Suppots values that are
            IDictionary&lt;string, object&gt;, IList&lt;object&gt;, strings,
            nulls, and any of the primitive types.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Encode(System.Object)">
            <summary>
            Encodes an object into a JSON string.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseObject(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses JSON object syntax (e.g. '{}')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseMember(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses JSON member syntax (e.g. '"keyname" : null')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseArray(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses JSON array syntax (e.g. '[]')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseValue(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses a value (i.e. the right-hand side of an object member assignment or
            an element in an array)
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseString(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses a JSON string (e.g. '"foo\u1234bar\n"')
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.ParseNumber(System.String,System.Int32,System.Int32@,System.Object@)">
            <summary>
            Parses a number. Returns a long if the number is an integer or has an exponent,
            otherwise returns a double.
            </summary>
        </member>
        <member name="M:Parse.Internal.Json.Accept(System.String,System.Int32,System.Text.RegularExpressions.Regex,System.Int32@,System.Text.RegularExpressions.Match@)">
            <summary>
            Matches the string to a regex, consuming part of the string and returning the match.
            </summary>
        </member>
        <member name="T:Parse.Internal.ParseDeleteOperation">
            <summary>
            An operation where a field is deleted from the object.
            </summary>
        </member>
        <member name="T:Parse.ParseConfig">
            <summary>
            The ParseConfig is a representation of the remote configuration object,
            that enables you to add things like feature gating, a/b testing or simple "Message of the day".
            </summary>
        </member>
        <member name="M:Parse.ParseConfig.GetAsync">
            <summary>
            Retrieves the ParseConfig asynchronously from the server.
            </summary>
            <returns>ParseConfig object that was fetched</returns>
        </member>
        <member name="M:Parse.ParseConfig.GetAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves the ParseConfig asynchronously from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>ParseConfig object that was fetched</returns>
        </member>
        <member name="M:Parse.ParseConfig.Get``1(System.String)">
            <summary>
            Gets a value for the key of a particular type.
            </summary>
            <typeparam name="T">The type to convert the value to. Supported types are
            ParseObject and its descendents, Parse types such as ParseRelation and ParseGeopoint,
            primitive types,IList&lt;T&gt;, IDictionary&lt;string, T&gt; and strings.</typeparam>
            <param name="key">The key of the element to get.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved
            and <paramref name="key"/> is not found.</exception>
            <exception cref="T:System.FormatException">The property under this <paramref name="key"/>
            key was found, but of a different type.</exception>
        </member>
        <member name="M:Parse.ParseConfig.TryGetValue``1(System.String,``0@)">
            <summary>
            Populates result with the value for the key, if possible.
            </summary>
            <typeparam name="T">The desired type for the value.</typeparam>
            <param name="key">The key to retrieve a value for.</param>
            <param name="result">The value for the given key, converted to the
            requested type, or null if unsuccessful.</param>
            <returns>true if the lookup and conversion succeeded, otherwise false.</returns>
        </member>
        <member name="P:Parse.ParseConfig.CurrentConfig">
            <summary>
            Gets the latest fetched ParseConfig.
            </summary>
            <returns>ParseConfig object</returns>
        </member>
        <member name="P:Parse.ParseConfig.Item(System.String)">
            <summary>
            Gets a value on the config.
            </summary>
            <param name="key">The key for the parameter.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            <returns>The value for the key.</returns>
        </member>
        <member name="T:Parse.ParseFieldNameAttribute">
            <summary>
            Specifies a field name for a property on a ParseObject subclass.
            </summary>
        </member>
        <member name="M:Parse.ParseFieldNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new ParseFieldName attribute.
            </summary>
            <param name="fieldName">The name of the field on the ParseObject that the
            property represents.</param>
        </member>
        <member name="P:Parse.ParseFieldNameAttribute.FieldName">
            <summary>
            Gets the name of the field represented by this property.
            </summary>
        </member>
        <member name="M:Parse.Internal.ReflectionHelpers.FindConstructor(System.Type,System.Type[])">
            <summary>
            This method helps simplify the process of getting a constructor for a type.
            A method like this exists in .NET but is not allowed in a Portable Class Library,
            so we've built our own.
            </summary>
            <param name="self"></param>
            <param name="parameterTypes"></param>
            <returns></returns>
        </member>
        <member name="T:Parse.Internal.SynchronizedEventHandler`1">
            <summary>
            Represents an event handler that calls back from the synchronization context
            that subscribed.
            <typeparam name="T">Should look like an EventArgs, but may not inherit EventArgs if T is implemented by the Windows team.</typeparam>
            </summary>
        </member>
        <member name="T:Parse.Internal.TaskQueue">
            <summary>
            A helper class for enqueuing tasks
            </summary>
        </member>
        <member name="F:Parse.Internal.TaskQueue.tail">
            <summary>
            We only need to keep the tail of the queue.  Cancelled tasks will
            just complete normally/immediately when their turn arrives.
            </summary>
        </member>
        <member name="M:Parse.Internal.TaskQueue.GetTaskToAwait(System.Threading.CancellationToken)">
            <summary>
            Gets a cancellable task that can be safely awaited and is dependent
            on the current tail of the queue. This essentially gives us a proxy
            for the tail end of the queue whose awaiting can be cancelled.
            </summary>
            <param name="cancellationToken">A cancellation token that cancels
            the task even if the task is still in the queue. This allows the
            running task to return immediately without breaking the dependency
            chain. It also ensures that errors do not propagate.</param>
            <returns>A new task that should be awaited by enqueued tasks.</returns>
        </member>
        <member name="M:Parse.Internal.TaskQueue.Enqueue``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)">
            <summary>
            Enqueues a task created by <paramref name="taskStart"/>.  If the task is
            cancellable (or should be able to be cancelled while it is waiting in the
            queue), pass a cancellationToken.
            </summary>
            <typeparam name="T">The type of task.</typeparam>
            <param name="taskStart">A function given a task to await once state is
            snapshotted (e.g. after capturing session tokens at the time of the save call).
            Awaiting this task will wait for the created task's turn in the queue.</param>
            <param name="cancellationToken">A cancellation token that can be used to
            cancel waiting in the queue.</param>
            <returns>The task created by the taskStart function.</returns>
        </member>
        <member name="T:Parse.ParseClassNameAttribute">
            <summary>
            Defines the class name for a subclass of ParseObject.
            </summary>
        </member>
        <member name="M:Parse.ParseClassNameAttribute.#ctor(System.String)">
            <summary>
            Constructs a new ParseClassName attribute.
            </summary>
            <param name="className">The class name to associate with the ParseObject subclass.</param>
        </member>
        <member name="P:Parse.ParseClassNameAttribute.ClassName">
            <summary>
            Gets the class name to associate with the ParseObject subclass.
            </summary>
        </member>
        <member name="T:Parse.ParseFile">
            <summary>
            ParseFile is a local representation of a file that is saved to the Parse cloud.
            </summary>
            <example>
            The workflow is to construct a <see cref="T:Parse.ParseFile"/> with data and a filename,
            then save it and set it as a field on a ParseObject:
            
            <code>
            var file = new ParseFile("hello.txt",
                new MemoryStream(Encoding.UTF8.GetBytes("hello")));
            await file.SaveAsync();
            var obj = new ParseObject("TestObject");
            obj["file"] = file;
            await obj.SaveAsync();
            </code>
            </example>
        </member>
        <member name="M:Parse.ParseFile.#ctor(System.String,System.Byte[],System.String)">
            <summary>
            Creates a new file from a byte array and a name.
            </summary>
            <param name="name">The file's name, ideally with an extension. The file name
            must begin with an alphanumeric character, and consist of alphanumeric
            characters, periods, spaces, underscores, or dashes.</param>
            <param name="data">The file's data.</param>
            <param name="mimeType">To specify the content-type used when uploading the
            file, provide this parameter.</param>
        </member>
        <member name="M:Parse.ParseFile.#ctor(System.String,System.IO.Stream,System.String)">
            <summary>
            Creates a new file from a stream and a name.
            </summary>
            <param name="name">The file's name, ideally with an extension. The file name
            must begin with an alphanumeric character, and consist of alphanumeric
            characters, periods, spaces, underscores, or dashes.</param>
            <param name="data">The file's data.</param>
            <param name="mimeType">To specify the content-type used when uploading the
            file, provide this parameter.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.Threading.CancellationToken)">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.IProgress{Parse.ParseUploadProgressEventArgs})">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="progress">The progress callback.</param>
        </member>
        <member name="M:Parse.ParseFile.SaveAsync(System.IProgress{Parse.ParseUploadProgressEventArgs},System.Threading.CancellationToken)">
            <summary>
            Saves the file to the Parse cloud.
            </summary>
            <param name="progress">The progress callback.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="F:Parse.ParseFile.MIMETypesDictionary">
            <summary>
            A list of file extensions to mime types as found here:
            http://stackoverflow.com/questions/58510/using-net-how-can-you-find-the-mime-type-of-a-file-based-on-the-file-signature
            </summary>
        </member>
        <member name="P:Parse.ParseFile.IsDirty">
            <summary>
            Gets whether the file still needs to be saved.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.Name">
            <summary>
            Gets the name of the file.  Before save is called, this is the filename given by
            the user.  After save is called, that name gets prefixed with a unique identifier.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.MimeType">
            <summary>
            Gets the MIME type of the file.  This is either passed in to the constructor or
            inferred from the file extension.  "unknown/unknown" will be used if neither is 
            available.
            </summary>
        </member>
        <member name="P:Parse.ParseFile.Url">
            <summary>
            Gets the url of the file.  It is only available after you save the file or after
            you get the file from a <see cref="T:Parse.ParseObject"/>.
            </summary>
        </member>
        <member name="T:Parse.ParseQueryExtensions">
            <summary>
            Provides extension methods for <see cref="T:Parse.ParseQuery`1"/> to support
            Linq-style queries.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.GetMethod``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Gets a MethodInfo for a top-level method call.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ContainsStub``1(System.Object,``0)">
            <summary>
            When a query is normalized, this is a placeholder to indicate we should
            add a WhereContainedIn() clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.NotContainsStub``1(System.Object,``0)">
            <summary>
            When a query is normalized, this is a placeholder to indicate we should
            add a WhereNotContainedIn() clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ContainsKeyStub(Parse.ParseObject,System.String)">
            <summary>
            When a query is normalized, this is a placeholder to indicate that we should
            add a WhereExists() clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.NotContainsKeyStub(Parse.ParseObject,System.String)">
            <summary>
            When a query is normalized, this is a placeholder to indicate that we should
            add a WhereDoesNotExist() clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.GetValue(System.Linq.Expressions.Expression)">
            <summary>
            Evaluates an expression and throws if the expression has components that can't be
            evaluated (e.g. uses the parameter that's only represented by an object on the server).
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.IsParseObjectGet(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Checks whether the MethodCallExpression is a call to ParseObject.Get(),
            which is the call we normalize all indexing into the ParseObject to.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.WhereMethodCall``1(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Converts a normalized method call expression into the appropriate ParseQuery clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.WhereBinaryExpression``1(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.BinaryExpression)">
            <summary>
            Converts a normalized binary expression into the appropriate ParseQuery clause.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.Where``1(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Filters a query based upon the predicate provided.
            </summary>
            <typeparam name="TSource">The type of ParseObject being queried for.</typeparam>
            <param name="source">The base <see cref="T:Parse.ParseQuery`1"/> to which
            the predicate will be added.</param>
            <param name="predicate">A function to test each ParseObject for a condition.
            The predicate must be able to be represented by one of the standard Where
            functions on ParseQuery</param>
            <returns>A new ParseQuery whose results will match the given predicate as
            well as the source's filters.</returns>
        </member>
        <member name="M:Parse.ParseQueryExtensions.GetOrderByPath``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Normalizes an OrderBy's keySelector expression and then extracts the path
            from the ParseObject.Get() call.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.OrderBy``2(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders a query based upon the key selector provided.
            </summary>
            <typeparam name="TSource">The type of ParseObject being queried for.</typeparam>
            <typeparam name="TSelector">The type of key returned by keySelector.</typeparam>
            <param name="source">The query to order.</param>
            <param name="keySelector">A function to extract a key from the ParseObject.</param>
            <returns>A new ParseQuery based on source whose results will be ordered by
            the key specified in the keySelector.</returns>
        </member>
        <member name="M:Parse.ParseQueryExtensions.OrderByDescending``2(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Orders a query based upon the key selector provided.
            </summary>
            <typeparam name="TSource">The type of ParseObject being queried for.</typeparam>
            <typeparam name="TSelector">The type of key returned by keySelector.</typeparam>
            <param name="source">The query to order.</param>
            <param name="keySelector">A function to extract a key from the ParseObject.</param>
            <returns>A new ParseQuery based on source whose results will be ordered by
            the key specified in the keySelector.</returns>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ThenBy``2(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Performs a subsequent ordering of a query based upon the key selector provided.
            </summary>
            <typeparam name="TSource">The type of ParseObject being queried for.</typeparam>
            <typeparam name="TSelector">The type of key returned by keySelector.</typeparam>
            <param name="source">The query to order.</param>
            <param name="keySelector">A function to extract a key from the ParseObject.</param>
            <returns>A new ParseQuery based on source whose results will be ordered by
            the key specified in the keySelector.</returns>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ThenByDescending``2(Parse.ParseQuery{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Performs a subsequent ordering of a query based upon the key selector provided.
            </summary>
            <typeparam name="TSource">The type of ParseObject being queried for.</typeparam>
            <typeparam name="TSelector">The type of key returned by keySelector.</typeparam>
            <param name="source">The query to order.</param>
            <param name="keySelector">A function to extract a key from the ParseObject.</param>
            <returns>A new ParseQuery based on source whose results will be ordered by
            the key specified in the keySelector.</returns>
        </member>
        <member name="M:Parse.ParseQueryExtensions.Join``4(Parse.ParseQuery{``0},Parse.ParseQuery{``1},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``1,``3}})">
            <summary>
            Correlates the elements of two queries based on matching keys.
            </summary>
            <typeparam name="TOuter">The type of ParseObjects of the first query.</typeparam>
            <typeparam name="TInner">The type of ParseObjects of the second query.</typeparam>
            <typeparam name="TKey">The type of the keys returned by the key selector
            functions.</typeparam>
            <typeparam name="TResult">The type of the result. This must match either
            TOuter or TInner</typeparam>
            <param name="outer">The first query to join.</param>
            <param name="inner">The query to join to the first query.</param>
            <param name="outerKeySelector">A function to extract a join key from the results of
            the first query.</param>
            <param name="innerKeySelector">A function to extract a join key from the results of
            the second query.</param>
            <param name="resultSelector">A function to select either the outer or inner query
            result to determine which query is the base query.</param>
            <returns>A new ParseQuery with a WhereMatchesQuery or WhereMatchesKeyInQuery
            clause based upon the query indicated in the <paramref name="resultSelector"/>.</returns>
        </member>
        <member name="T:Parse.ParseQueryExtensions.ObjectNormalizer">
            <summary>
            Visits an Expression, converting ParseObject.Get/ParseObject[]/ParseObject.Property,
            and nested indices into a single call to ParseObject.Get() with a "field path" like
            "foo.bar.baz"
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ObjectNormalizer.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Check for a ParseFieldName attribute and use that as the path component, turning
            properties like foo.ObjectId into foo.Get("objectId")
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.ObjectNormalizer.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            If a ParseObject.Get() call has been cast, just change the generic parameter.
            </summary>
        </member>
        <member name="T:Parse.ParseQueryExtensions.WhereNormalizer">
            <summary>
            Normalizes Where expressions.
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.WhereNormalizer.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Normalizes binary operators.  &lt;, &gt;, &lt;=, &gt;= !=, and ==
            This puts the ParseObject.Get() on the left side of the operation
            (reversing it if necessary), and normalizes the ParseObject.Get()
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.WhereNormalizer.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            If a ! operator is used, this removes the ! and instead calls the equivalent
            function (so e.g. == becomes !=, &lt; becomes &gt;=, Contains becomes NotContains)
            </summary>
        </member>
        <member name="M:Parse.ParseQueryExtensions.WhereNormalizer.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Normalizes .Equals into == and Contains() into the appropriate stub.
            </summary>
        </member>
        <member name="T:Parse.ParseACL">
            <summary>
            A ParseACL is used to control which users and roles can access or modify a particular object.  Each
            <see cref="T:Parse.ParseObject"/> can have its own ParseACL.  You can grant read and write permissions
            separately to specific users, to groups of users that belong to roles, or you can grant permissions
            to "the public" so that, for example, any user could read a particular object but only a particular
            set of users could write to that object.
            </summary>
        </member>
        <member name="M:Parse.ParseACL.#ctor">
            <summary>
            Creates an ACL with no permissions granted.
            </summary>
        </member>
        <member name="M:Parse.ParseACL.#ctor(Parse.ParseUser)">
            <summary>
            Creates an ACL where only the provided user has access.
            </summary>
            <param name="owner">The only user that can read or write objects governed by this ACL.</param>
        </member>
        <member name="M:Parse.ParseACL.SetReadAccess(System.String,System.Boolean)">
            <summary>
            Sets whether the given user id is allowed to read this object.
            </summary>
            <param name="userId">The objectId of the user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetReadAccess(Parse.ParseUser,System.Boolean)">
            <summary>
            Sets whether the given user is allowed to read this object.
            </summary>
            <param name="user">The user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetWriteAccess(System.String,System.Boolean)">
            <summary>
            Sets whether the given user id is allowed to write this object.
            </summary>
            <param name="userId">The objectId of the user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.SetWriteAccess(Parse.ParseUser,System.Boolean)">
            <summary>
            Sets whether the given user is allowed to write this object.
            </summary>
            <param name="user">The user.</param>
            <param name="allowed">Whether the user has permission.</param>
        </member>
        <member name="M:Parse.ParseACL.GetReadAccess(System.String)">
            <summary>
            Gets whether the given user id is *explicitly* allowed to read this object.
            Even if this returns false, the user may still be able to read it if
            PublicReadAccess is true or a role that the user belongs to has read access.
            </summary>
            <param name="userId">The user objectId to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetReadAccess(Parse.ParseUser)">
            <summary>
            Gets whether the given user is *explicitly* allowed to read this object.
            Even if this returns false, the user may still be able to read it if
            PublicReadAccess is true or a role that the user belongs to has read access.
            </summary>
            <param name="user">The user to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetWriteAccess(System.String)">
            <summary>
            Gets whether the given user id is *explicitly* allowed to write this object.
            Even if this returns false, the user may still be able to write it if
            PublicReadAccess is true or a role that the user belongs to has write access.
            </summary>
            <param name="userId">The user objectId to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetWriteAccess(Parse.ParseUser)">
            <summary>
            Gets whether the given user is *explicitly* allowed to write this object.
            Even if this returns false, the user may still be able to write it if
            PublicReadAccess is true or a role that the user belongs to has write access.
            </summary>
            <param name="user">The user to check.</param>
            <returns>Whether the user has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.SetRoleReadAccess(System.String,System.Boolean)">
            <summary>
            Sets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to read this object.
            </summary>
            <param name="roleName">The name of the role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.SetRoleReadAccess(Parse.ParseRole,System.Boolean)">
            <summary>
            Sets whether users belonging to the given role are allowed to read this object.
            </summary>
            <param name="role">The role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.GetRoleReadAccess(System.String)">
            <summary>
            Gets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to read this object. Even if this returns false, the role may still be
            able to read it if a parent role has read access.
            </summary>
            <param name="roleName">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetRoleReadAccess(Parse.ParseRole)">
            <summary>
            Gets whether users belonging to the role are allowed to read this object.
            Even if this returns false, the role may still be able to read it if a
            parent role has read access.
            </summary>
            <param name="role">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.SetRoleWriteAccess(System.String,System.Boolean)">
            <summary>
            Sets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to write this object.
            </summary>
            <param name="roleName">The name of the role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.SetRoleWriteAccess(Parse.ParseRole,System.Boolean)">
            <summary>
            Sets whether users belonging to the given role are allowed to write this object.
            </summary>
            <param name="role">The role.</param>
            <param name="allowed">Whether the role has access.</param>
        </member>
        <member name="M:Parse.ParseACL.GetRoleWriteAccess(System.String)">
            <summary>
            Gets whether users belonging to the role with the given <paramref name="roleName"/>
            are allowed to write this object. Even if this returns false, the role may still be
            able to write it if a parent role has write access.
            </summary>
            <param name="roleName">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="M:Parse.ParseACL.GetRoleWriteAccess(Parse.ParseRole)">
            <summary>
            Gets whether users belonging to the role are allowed to write this object.
            Even if this returns false, the role may still be able to write it if a
            parent role has write access.
            </summary>
            <param name="role">The name of the role.</param>
            <returns>Whether the role has access.</returns>
        </member>
        <member name="P:Parse.ParseACL.PublicReadAccess">
            <summary>
            Gets or sets whether the public is allowed to read this object.
            </summary>
        </member>
        <member name="P:Parse.ParseACL.PublicWriteAccess">
            <summary>
            Gets or sets whether the public is allowed to write this object.
            </summary>
        </member>
        <member name="T:Parse.ParseClient">
            <summary>
            ParseClient contains static functions that handle global
            configuration for the Parse library.
            </summary>
        </member>
        <member name="M:Parse.ParseClient.Initialize(System.String,System.String)">
            <summary>
            Authenticates this client as belonging to your application. This must be
            called before your application can use the Parse library. The recommended
            way is to put a call to <c>ParseFramework.Initialize</c> in your
            Application startup.
            </summary>
            <param name="applicationId">The Application ID provided in the Parse dashboard.
            </param>
            <param name="dotnetKey">The .NET API Key provided in the Parse dashboard.
            </param>
        </member>
        <member name="M:Parse.ParseClient.RequestAsync(System.String,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            Convenience alias for RequestAsync that takes a string instead of a Uri.
            </summary>
        </member>
        <member name="M:Parse.ParseClient.RequestAsync(System.String,System.Uri,System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            The main mechanism for making requests to Parse.  Attaches headers related to
            the SDK, session token, etc., then JSON-parses the result of the request and throws
            a ParseException if necessary.
            </summary>
            <param name="method">The HTTP method to use.</param>
            <param name="relativeUri">A relative URI for the API.</param>
            <param name="cancellationToken">The session token for the request.</param>
            <param name="data">A JSON-style data object that will be stringified
            for the request body.</param>
            <param name="sessionToken">The cancellation token for the request.</param>
            <returns>A tuple indicating the HTTP status code and the JSON data
            returned by the request.</returns>
        </member>
        <member name="M:Parse.ParseClient.UploadAsync(System.Uri,System.String,System.String,System.IO.Stream,System.IProgress{Parse.ParseUploadProgressEventArgs},System.Threading.CancellationToken)">
            <summary>
            Performs an upload that reports progress.
            </summary>
        </member>
        <member name="M:Parse.ParseClient.As``1(System.Object)">
            <summary>
            Performs a ConvertTo, but returns null if the object can't be
            converted to that type.
            </summary>
        </member>
        <member name="M:Parse.ParseClient.ConvertTo``1(System.Object)">
            <summary>
            Converts a value to the requested type -- coercing primitives to
            the desired type, wrapping lists and dictionaries appropriately,
            or else passing the object along to the caller unchanged.
            
            This should be used on any containers that might be coming from a
            user to normalize the collection types.  Collection types coming from
            JSON deserialization can be safely assumed to be lists or dictionaries of
            objects.
            </summary>
        </member>
        <member name="F:Parse.ParseClient.interfaceLookupCache">
            <summary>
            Holds a dictionary that maps a cache of interface types for related concrete types.
            The lookup is slow the first time for each type because it has to enumerate all interface
            on the object type, but made fast by the cache.
            
            The map is:
               (object type, generic interface type) => constructed generic type
            </summary>
        </member>
        <member name="M:Parse.ParseClient.DeepTraversal(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Flattens dictionaries and lists into a single enumerable of all contained objects
            that can then be queried over.
            </summary>
            <param name="root">The root of the traversal</param>
            <param name="traverseParseObjects">Whether to traverse into ParseObjects' children</param>
            <param name="yieldRoot">Whether to include the root in the result</param>
            <returns></returns>
        </member>
        <member name="T:Parse.ParseCloud">
            <summary>
            The ParseCloud class provides methods for interacting with Parse Cloud Functions.
            </summary>
            <example>
            For example, this sample code calls the
            "validateGame" Cloud Function and calls processResponse if the call succeeded
            and handleError if it failed.
            
            <code>
            var result =
                await ParseCloud.CallFunctionAsync&lt;IDictionary&lt;string, object&gt;&gt;("validateGame", parameters);
            </code>
            </example>
        </member>
        <member name="M:Parse.ParseCloud.CallFunctionAsync``1(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Calls a cloud function.
            </summary>
            <typeparam name="T">The type of data you will receive from the cloud function.  This
            can be an IDictionary, string, IList, ParseObject, or any other type supported by
            ParseObject.</typeparam>
            <param name="name">The cloud function to call.</param>
            <param name="parameters">The parameters to send to the cloud function.  This
            dictionary can contain anything that could be passed into a ParseObject except for
            ParseObjects themselves.</param>
            <returns>The result of the cloud call.</returns>
        </member>
        <member name="M:Parse.ParseCloud.CallFunctionAsync``1(System.String,System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            Calls a cloud function.
            </summary>
            <typeparam name="T">The type of data you will receive from the cloud function.  This
            can be an IDictionary, string, IList, ParseObject, or any other type supported by
            ParseObject.</typeparam>
            <param name="name">The cloud function to call.</param>
            <param name="parameters">The parameters to send to the cloud function.  This
            dictionary can contain anything that could be passed into a ParseObject except for
            ParseObjects themselves.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The result of the cloud call.</returns>
        </member>
        <member name="T:Parse.ParseException">
            <summary>
            Exceptions that may occur when sending requests to Parse.
            </summary>
        </member>
        <member name="P:Parse.ParseException.Code">
            <summary>
            The Parse error code associated with the exception.
            </summary>
        </member>
        <member name="T:Parse.ParseException.ErrorCode">
            <summary>
            Error codes that may be delivered in response to requests to Parse.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.OtherCause">
            <summary>
            Error code indicating that an unknown error or an error unrelated to Parse
            occurred.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InternalServerError">
            <summary>
            Error code indicating that something has gone wrong with the server.
            If you get this error code, it is Parse's fault. Please report the bug to
            https://parse.com/help.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ConnectionFailed">
            <summary>
            Error code indicating the connection to the Parse servers failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ObjectNotFound">
            <summary>
            Error code indicating the specified object doesn't exist.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidQuery">
            <summary>
            Error code indicating you tried to query with a datatype that doesn't
            support it, like exact matching an array or object.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidClassName">
            <summary>
            Error code indicating a missing or invalid classname. Classnames are
            case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the
            only valid characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.MissingObjectId">
            <summary>
            Error code indicating an unspecified object id.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidKeyName">
            <summary>
            Error code indicating an invalid key name. Keys are case-sensitive. They
            must start with a letter, and a-zA-Z0-9_ are the only valid characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidPointer">
            <summary>
            Error code indicating a malformed pointer. You should not see this unless
            you have been mucking about changing internal Parse code.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidJSON">
            <summary>
            Error code indicating that badly formed JSON was received upstream. This
            either indicates you have done something unusual with modifying how
            things encode to JSON, or the network is failing badly.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.CommandUnavailable">
            <summary>
            Error code indicating that the feature you tried to access is only
            available internally for testing purposes.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.NotInitialized">
            <summary>
            You must call Parse.initialize before using the Parse library.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.IncorrectType">
            <summary>
            Error code indicating that a field was set to an inconsistent type.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidChannelName">
            <summary>
            Error code indicating an invalid channel name. A channel name is either
            an empty string (the broadcast channel) or contains only a-zA-Z0-9_
            characters and starts with a letter.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.PushMisconfigured">
            <summary>
            Error code indicating that push is misconfigured.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ObjectTooLarge">
            <summary>
            Error code indicating that the object is too large.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.OperationForbidden">
            <summary>
            Error code indicating that the operation isn't allowed for clients.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.CacheMiss">
            <summary>
            Error code indicating the result was not found in the cache.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidNestedKey">
            <summary>
            Error code indicating that an invalid key was used in a nested
            JSONObject.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidFileName">
            <summary>
            Error code indicating that an invalid filename was used for ParseFile.
            A valid file name contains only a-zA-Z0-9_. characters and is between 1
            and 128 characters.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidACL">
            <summary>
            Error code indicating an invalid ACL was provided.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.Timeout">
            <summary>
            Error code indicating that the request timed out on the server. Typically
            this indicates that the request is too expensive to run.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidEmailAddress">
            <summary>
            Error code indicating that the email address was invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.DuplicateValue">
            <summary>
            Error code indicating that a unique field was given a value that is
            already taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidRoleName">
            <summary>
            Error code indicating that a role's name is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ExceededQuota">
            <summary>
            Error code indicating that an application quota was exceeded.  Upgrade to
            resolve.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ScriptFailed">
            <summary>
            Error code indicating that a Cloud Code script failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.ValidationFailed">
            <summary>
            Error code indicating that a Cloud Code validation failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.FileDeleteFailed">
            <summary>
            Error code indicating that deleting a file failed.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.RequestLimitExceeded">
            <summary>
            Error code indicating that the application has exceeded its request limit.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidEventName">
            <summary>
            Error code indicating that the provided event name is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UsernameMissing">
            <summary>
            Error code indicating that the username is missing or empty.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.PasswordMissing">
            <summary>
            Error code indicating that the password is missing or empty.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UsernameTaken">
            <summary>
            Error code indicating that the username has already been taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailTaken">
            <summary>
            Error code indicating that the email has already been taken.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailMissing">
            <summary>
            Error code indicating that the email is missing, but must be specified.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.EmailNotFound">
            <summary>
            Error code indicating that a user with the specified email was not found.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.SessionMissing">
            <summary>
            Error code indicating that a user object without a valid session could
            not be altered.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.MustCreateUserThroughSignup">
            <summary>
            Error code indicating that a user can only be created through signup.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.AccountAlreadyLinked">
            <summary>
            Error code indicating that an an account being linked is already linked
            to another user.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidSessionToken">
            <summary>
            Error code indicating that the current session token is invalid.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.LinkedIdMissing">
            <summary>
            Error code indicating that a user cannot be linked to an account because
            that account's id could not be found.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.InvalidLinkedSession">
            <summary>
            Error code indicating that a user with a linked (e.g. Facebook) account
            has an invalid session.
            </summary>
        </member>
        <member name="F:Parse.ParseException.ErrorCode.UnsupportedService">
            <summary>
            Error code indicating that a service being linked (e.g. Facebook or
            Twitter) is unsupported.
            </summary>
        </member>
        <member name="T:Parse.ParseExtensions">
            <summary>
            Provides convenience extension methods for working with collections
            of ParseObjects so that you can easily save and fetch them in batches.
            </summary>
        </member>
        <member name="M:Parse.ParseExtensions.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Saves all of the ParseObjects in the enumeration.  Equivalent to
            calling <see cref="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseExtensions.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Saves all of the ParseObjects in the enumeration.  Equivalent to
            calling
            <see cref="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to save.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the enumeration.  Equivalent to
            calling <see cref="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the enumeration.  Equivalent to
            calling
            <see cref="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the enumeration that don't already have
            data.  Equivalent to calling
            <see cref="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the enumeration that don't already have
            data.  Equivalent to calling
            <see cref="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.Or``1(Parse.ParseQuery{``0},Parse.ParseQuery{``0}[])">
            <summary>
            Constructs a query that is the or of the given queries.
            </summary>
            <typeparam name="T">The type of ParseObject being queried.</typeparam>
            <param name="source">An initial query to 'or' with additional queries.</param>
            <param name="queries">The list of ParseQueries to 'or' together.</param>
            <returns>A query that is the or of the given queries.</returns>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAsync``1(``0)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
        </member>
        <member name="M:Parse.ParseExtensions.FetchAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObjhect to fetch.</param>
        </member>
        <member name="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0,System.Threading.CancellationToken)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="obj">The ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:Parse.ParseGeoDistance">
            <summary>
            Represents a distance between two ParseGeoPoints.
            </summary>
        </member>
        <member name="M:Parse.ParseGeoDistance.#ctor(System.Double)">
            <summary>
            Creates a ParseGeoDistance.
            </summary>
            <param name="radians">The distance in radians.</param>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromMiles(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of miles.
            </summary>
            <param name="miles">The number of miles.</param>
            <returns>A ParseGeoDistance for the given number of miles.</returns>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromKilometers(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of kilometers.
            </summary>
            <param name="kilometers">The number of kilometers.</param>
            <returns>A ParseGeoDistance for the given number of kilometers.</returns>
        </member>
        <member name="M:Parse.ParseGeoDistance.FromRadians(System.Double)">
            <summary>
            Gets a ParseGeoDistance from a number of radians.
            </summary>
            <param name="radians">The number of radians.</param>
            <returns>A ParseGeoDistance for the given number of radians.</returns>
        </member>
        <member name="P:Parse.ParseGeoDistance.Radians">
            <summary>
            Gets the distance in radians.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoDistance.Miles">
            <summary>
            Gets the distance in miles.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoDistance.Kilometers">
            <summary>
            Gets the distance in kilometers.
            </summary>
        </member>
        <member name="T:Parse.ParseGeoPoint">
            <summary>
            ParseGeoPoint represents a latitude / longitude point that may be associated
            with a key in a ParseObject or used as a reference point for geo queries.
            This allows proximity-based queries on the key.
            
            Only one key in a class may contain a GeoPoint.
            </summary>
        </member>
        <member name="M:Parse.ParseGeoPoint.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a ParseGeoPoint with the specified latitude and longitude.
            </summary>
            <param name="latitude">The point's latitude.</param>
            <param name="longitude">The point's longitude.</param>
        </member>
        <member name="M:Parse.ParseGeoPoint.DistanceTo(Parse.ParseGeoPoint)">
            <summary>
            Get the distance in radians between this point and another GeoPoint. This is the smallest angular
            distance between the two points.
            </summary>
            <param name="point">GeoPoint describing the other point being measured against.</param>
            <returns>The distance in between the two points.</returns>
        </member>
        <member name="P:Parse.ParseGeoPoint.Latitude">
            <summary>
            Gets or sets the latitude of the GeoPoint. Valid range is [-90, 90].
            Extremes should not be used.
            </summary>
        </member>
        <member name="P:Parse.ParseGeoPoint.Longitude">
            <summary>
            Gets or sets the longitude. Valid range is [-180, 180].
            Extremes should not be used.
            </summary>
        </member>
        <member name="T:Parse.ParseObject">
            <summary>
            The ParseObject is a local representation of data that can be saved and
            retrieved from the Parse cloud.</summary>
            <remarks>
            <para>
            The basic workflow for creating new data is to construct a new ParseObject,
            use the indexer to fill it with data, and then use SaveAsync() to persist to the
            database.
            </para>
            <para>
            The basic workflow for accessing existing data is to use a ParseQuery
            to specify which existing data to retrieve.
            </para>
            </remarks>
        </member>
        <member name="M:Parse.ParseObject.#ctor">
            <summary>
            Constructor for use in ParseObject subclasses. Subclasses must specify a ParseClassName attribute.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.#ctor(System.String)">
            <summary>
            Constructs a new ParseObject with no data in it.  A ParseObject constructed in this way will
            not have an ObjectId and will not persist to the database until <see cref="M:Parse.ParseObject.SaveAsync"/>
            is called.
            </summary>
            <remarks>
            Class names must be alphanumerical plus underscore, and start with a letter.  It is recommended
            to name classes in CamelCaseLikeThis.
            </remarks>
            <param name="className">The className for this ParseObject.</param>
        </member>
        <member name="M:Parse.ParseObject.SetProperty``1(``0,System.String)">
            <summary>
            Sets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <param name="value">The new value.</param>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The type for the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetRelationProperty``1(System.String)">
            <summary>
            Gets a relation for a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The ParseRelation for the property.</returns>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The ParseObject subclass type of the ParseRelation.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetProperty``1(System.String)">
            <summary>
            Gets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The value of the property.</returns>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The return type of the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.GetProperty``1(``0,System.String)">
            <summary>
            Gets the value of a property based upon its associated ParseFieldName attribute.
            </summary>
            <returns>The value of the property.</returns>
            <param name="defaultValue">The value to return if the property is not present on the ParseObject.</param>
            <param name="propertyName">The name of the property.</param>
            <typeparam name="T">The return type of the property.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.SetDefaultValues">
            <summary>
            Allows subclasses to set values for non-pointer construction.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.GetFactory(System.String)">
            <summary>
            Gets the appropriate factory for the given class name.  If there is no factory for the class,
            a factory that produces a regular ParseObject will be created.
            </summary>
            <param name="className">The class name for the ParseObjects the factory will create.</param>
            <returns></returns>
        </member>
        <member name="M:Parse.ParseObject.Create(System.String)">
            <summary>
            Creates a new ParseObject based upon a class name.  If the class name is a special type (e.g.
            for <see cref="T:Parse.ParseUser"/>), then the appropriate type of ParseObject is returned.
            </summary>
            <param name="className">The class of object to create.</param>
            <returns>A new ParseObject for the given class name.</returns>
        </member>
        <member name="M:Parse.ParseObject.CreateWithoutData(System.String,System.String)">
            <summary>
            Creates a reference to an existing ParseObject for use in creating associations between
            ParseObjects.  Calling <see cref="P:Parse.ParseObject.IsDataAvailable"/> on this object will return
            <c>false</c> until <see cref="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)"/> has been called.
            No network request will be made.
            </summary>
            <param name="className">The object's class.</param>
            <param name="objectId">The object id for the referenced object.</param>
            <returns>A ParseObject without data.</returns>
        </member>
        <member name="M:Parse.ParseObject.Create``1">
            <summary>
            Creates a new ParseObject based upon a given subclass type.
            </summary>
            <returns>A new ParseObject for the given class name.</returns>
        </member>
        <member name="M:Parse.ParseObject.CreateWithoutData``1(System.String)">
            <summary>
            Creates a reference to an existing ParseObject for use in creating associations between
            ParseObjects.  Calling <see cref="P:Parse.ParseObject.IsDataAvailable"/> on this object will return
            <c>false</c> until <see cref="M:Parse.ParseExtensions.FetchIfNeededAsync``1(``0)"/> has been called.
            No network request will be made.
            </summary>
            <param name="objectId">The object id for the referenced object.</param>
            <returns>A ParseObject without data.</returns>
        </member>
        <member name="M:Parse.ParseObject.RegisterSubclass``1">
            <summary>
            Registers a custom subclass type with the Parse SDK, enabling strong-typing of those ParseObjects whenever
            they appear. Subclasses must specify the ParseClassName attribute, have a default constructor, and properties
            backed by ParseObject fields should have ParseFieldName attributes supplied.
            </summary>
            <typeparam name="T">The ParseObject subclass type to register.</typeparam>
        </member>
        <member name="M:Parse.ParseObject.Revert">
            <summary>
            Clears any changes to this object made since the last call to <see cref="M:Parse.ParseObject.SaveAsync"/>.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CheckpointMutableContainer(System.Object)">
            <summary>
            Updates the JSON cache value for the given object.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CheckForChangesToMutableContainer(System.String,System.Object)">
            <summary>
            Inspects to see if a given mutable container owned by this object has
            been mutated, and treats any mutation as a new "set" operation.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CheckForChangesToMutableContainers">
            <summary>
            Inspects to see if any mutable container owned by this object has been mutated, and
            treats any mutation as a new 'Set' operation.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CollectFetchedObjects">
            <summary>
            Deep traversal of this object to grab a copy of any object referenced by this object.
            These instances may have already been fetched, and we don't want to lose their data when
            refreshing or saving.
            </summary>
            <returns>Map of objectId to ParseObject which have been fetched.</returns>
        </member>
        <member name="M:Parse.ParseObject.StartSave">
            <summary>
            Pushes new operations onto the queue and returns the current set of operations.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.SaveAsync">
            <summary>
            Saves this object to the server.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.SaveAsync(System.Threading.CancellationToken)">
            <summary>
            Saves this object to the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.FetchAsyncInternal(System.Threading.CancellationToken)">
            <summary>
            Fetches this object with the data from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.FetchIfNeededAsyncInternal(System.Threading.CancellationToken)">
            <summary>
            If this ParseObject has not been fetched (i.e. <see cref="P:Parse.ParseObject.IsDataAvailable"/> returns
            false), fetches this object with the data from the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.DeleteAsync">
            <summary>
            Deletes this object on the server.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.DeleteAsync(System.Threading.CancellationToken)">
            <summary>
            Deletes this object on the server.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.CollectDirtyChildren(System.Object,System.Collections.Generic.IList{Parse.ParseObject})">
            <summary>
            Helper version of CollectDirtyChildren so that callers don't have to add the internally
            used parameters.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.CanBeSerializedAsValue(System.Object)">
            <summary>
            Returns true if the given object can be serialized for saving as a value
            that is pointed to by a ParseObject.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.EnqueueForAll``1(System.Collections.Generic.IEnumerable{Parse.ParseObject},System.Func{System.Threading.Tasks.Task,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Adds a task to the queue for all of the given objects.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects that don't have data in the provided list.
            </summary>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllIfNeededAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects that don't have data in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fetches all of the objects in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the provided list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.FetchAllInternalAsync``1(System.Collections.Generic.IEnumerable{``0},System.Boolean,System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Fetches all of the objects in the list.
            </summary>
            <param name="objects">The objects to fetch.</param>
            <param name="force">If false, only objects without data will be fetched.</param>
            <param name="toAwait">A task to await before starting.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list passed in for convenience.</returns>
        </member>
        <member name="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Saves each object in the provided list.
            </summary>
            <param name="objects">The objects to save.</param>
        </member>
        <member name="M:Parse.ParseObject.SaveAllAsync``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Saves each object in the provided list.
            </summary>
            <param name="objects">The objects to save.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseObject.Remove(System.String)">
            <summary>
            Removes a key from the object's data if it exists.
            </summary>
            <param name="key">The key to remove.</param>
        </member>
        <member name="M:Parse.ParseObject.ApplyOperations(System.Collections.Generic.IDictionary{System.String,Parse.Internal.IParseFieldOperation},System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Updates the estimated values in the map based on the given set of ParseFieldOperations.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.RebuildEstimatedData">
            <summary>
            Regenerates the estimatedData map from the serverData and operations.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.PerformOperation(System.String,Parse.Internal.IParseFieldOperation)">
            <summary>
            PerformOperation is like setting a value at an index, but instead of
            just taking a new value, it takes a ParseFieldOperation that modifies the value.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.OnSettingValue(System.String@,System.Object@)">
            <summary>
            Override to run validations on key/value pairs.  Make sure to still
            call the base version.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.Set(System.String,System.Object)">
            <summary>
            Perform Set internally which is not gated by mutability check.
            </summary>
            <param name="key">key for the object.</param>
            <param name="value">the value for the key.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String)">
            <summary>
            Atomically increments the given key by 1.
            </summary>
            <param name="key">The key to increment.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String,System.Int64)">
            <summary>
            Atomically increments the given key by the given number.
            </summary>
            <param name="key">The key to increment.</param>
            <param name="amount">The amount to increment by.</param>
        </member>
        <member name="M:Parse.ParseObject.Increment(System.String,System.Double)">
            <summary>
            Atomically increments the given key by the given number.
            </summary>
            <param name="key">The key to increment.</param>
            <param name="amount">The amount to increment by.</param>
        </member>
        <member name="M:Parse.ParseObject.AddToList(System.String,System.Object)">
            <summary>
            Atomically adds an object to the end of the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The object to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddRangeToList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically adds objects to the end of the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddUniqueToList(System.String,System.Object)">
            <summary>
            Atomically adds an object to the end of the list associated with the given key,
            only if it is not already present in the list.  The position of the insert is not
            guaranteed.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The object to add.</param>
        </member>
        <member name="M:Parse.ParseObject.AddRangeUniqueToList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically adds objects to the end of the list associated with the given key,
            only if they are not already present in the list.  The position of the inserts are not
            guaranteed.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to add.</param>
        </member>
        <member name="M:Parse.ParseObject.RemoveAllFromList``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Atomically removes all instances of the objects in <paramref name="values"/>
            from the list associated with the given key.
            </summary>
            <param name="key">The key.</param>
            <param name="values">The objects to remove.</param>
        </member>
        <member name="M:Parse.ParseObject.ContainsKey(System.String)">
            <summary>
            Returns whether this object has a particular key.
            </summary>
            <param name="key">The key to check for</param>
        </member>
        <member name="M:Parse.ParseObject.Get``1(System.String)">
            <summary>
            Gets a value for the key of a particular type.
            <typeparam name="T">The type to convert the value to. Supported types are
            ParseObject and its descendents, Parse types such as ParseRelation and ParseGeopoint,
            primitive types,IList&lt;T&gt;, IDictionary&lt;string, T&gt;, and strings.</typeparam>
            <param name="key">The key of the element to get.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            </summary>
        </member>
        <member name="M:Parse.ParseObject.GetRelation``1(System.String)">
            <summary>
            Access or create a Relation value for a key.
            </summary>
            <typeparam name="T">The type of object to create a relation for.</typeparam>
            <param name="key">The key for the relation field.</param>
            <returns>A ParseRelation for the key.</returns>
        </member>
        <member name="M:Parse.ParseObject.TryGetValue``1(System.String,``0@)">
            <summary>
            Populates result with the value for the key, if possible.
            </summary>
            <typeparam name="T">The desired type for the value.</typeparam>
            <param name="key">The key to retrieve a value for.</param>
            <param name="result">The value for the given key, converted to the
            requested type, or null if unsuccessful.</param>
            <returns>true if the lookup and conversion succeeded, otherwise
            false.</returns>
        </member>
        <member name="M:Parse.ParseObject.HasSameId(Parse.ParseObject)">
            <summary>
            A helper function for checking whether two ParseObjects point to
            the same object in the cloud.
            </summary>
        </member>
        <member name="M:Parse.ParseObject.IsKeyDirty(System.String)">
            <summary>
            Indicates whether key is unsaved for this ParseObject.
            </summary>
            <param name="key">The key to check for.</param>
            <returns><c>true</c> if the key has been altered and not saved yet, otherwise
            <c>false</c>.</returns>
        </member>
        <member name="M:Parse.ParseObject.SetObjectIdInternal(System.String)">
            <summary>
            Sets the objectId without marking dirty.
            </summary>
            <param name="objectId">The new objectId</param>
        </member>
        <member name="M:Parse.ParseObject.Add(System.String,System.Object)">
            <summary>
            Adds a value for the given key, throwing an Exception if the key
            already has a value.
            </summary>
            <remarks>
            This allows you to use collection initialization syntax when creating ParseObjects,
            such as:
            <code>
            var obj = new ParseObject("MyType")
            {
                {"name", "foo"},
                {"count", 10},
                {"found", false}
            };
            </code>
            </remarks>
            <param name="key">The key for which a value should be set.</param>
            <param name="value">The value for the key.</param>
        </member>
        <member name="M:Parse.ParseObject.GetQuery(System.String)">
            <summary>
            Gets a <see cref="T:Parse.ParseQuery`1"/> for the type of object specified by
            <paramref name="className"/>
            </summary>
            <param name="className">The class name of the object.</param>
            <returns>A new <see cref="T:Parse.ParseQuery`1"/>.</returns>
        </member>
        <member name="M:Parse.ParseObject.OnFieldsChanged(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Raises change notifications for all properties associated with the given
            field names.  If fieldNames is null, this will notify for all known field-linked
            properties (e.g. this happens when we recalculate all estimated data from scratch)
            </summary>
        </member>
        <member name="M:Parse.ParseObject.OnPropertyChanged(System.String)">
            <summary>
            Raises change notifications for a property.  Passing null or the empty string
            notifies the binding framework that all properties/indexes have changed.
            Passing "Item[]" tells the binding framework that all indexed values
            have changed (but not all properties)
            </summary>
        </member>
        <member name="P:Parse.ParseObject.Item(System.String)">
            <summary>
            Gets or sets a value on the object.  It is recommended to name
            keys in partialCamelCaseLikeThis.
            </summary>
            <param name="key">The key for the object.  Keys must be alphanumeric plus underscore
            and start with a letter.</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is
            retrieved and <paramref name="key"/> is not found.</exception>
            <returns>The value for the key.</returns>
        </member>
        <member name="P:Parse.ParseObject.IsDataAvailable">
            <summary>
            Gets whether the ParseObject has been fetched.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.Keys">
            <summary>
            Gets a set view of the keys contained in this object.  This does not include createdAt,
            updatedAt, or objectId.  It does include things like username and ACL.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ACL">
            <summary>
            Gets or sets the ParseACL governing this object.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.IsNew">
            <summary>
            Returns true if this object was created by the Parse server when the
            object might have already been there (e.g. in the case of a Facebook
            login)
            </summary>
        </member>
        <member name="P:Parse.ParseObject.UpdatedAt">
            <summary>
            Gets the last time this object was updated as the server sees it, so that if you make changes
            to a ParseObject, then wait a while, and then call <see cref="M:Parse.ParseObject.SaveAsync"/>, the updated time
            will be the time of the <see cref="M:Parse.ParseObject.SaveAsync"/> call rather than the time the object was
            changed locally.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.CreatedAt">
            <summary>
            Gets the first time this object was saved as the server sees it, so that if you create a
            ParseObject, then wait a while, and then call <see cref="M:Parse.ParseObject.SaveAsync"/>, the
            creation time will be the time of the first <see cref="M:Parse.ParseObject.SaveAsync"/> call rather than
            the time the object was created locally.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.IsDirty">
            <summary>
            Indicates whether this ParseObject has unsaved changes.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ObjectId">
            <summary>
            Gets or sets the object id. An object id is assigned as soon as an object is
            saved to the server. The combination of a <see cref="P:Parse.ParseObject.ClassName"/> and an
            <see cref="P:Parse.ParseObject.ObjectId"/> uniquely identifies an object in your application.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.ClassName">
            <summary>
            Gets the class name for the ParseObject.
            </summary>
        </member>
        <member name="P:Parse.ParseObject.PropertyMappings">
            <summary>
            Gets the set of fieldName->propertyName mappings for the current class.
            </summary>
        </member>
        <member name="E:Parse.ParseObject.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="T:Parse.ParseQuery`1">
             <summary>
             The ParseQuery class defines a query that is used to fetch ParseObjects. The
             most common use case is finding all objects that match a query through the
             <see cref="M:Parse.ParseQuery`1.FindAsync"/> method.
             </summary>
             <example>
             This sample code fetches all objects of
             class <c>"MyClass"</c>:
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             IEnumerable&lt;ParseObject&gt; result = await query.FindAsync();
             </code>
            
             A ParseQuery can also be used to retrieve a single object whose id is known,
             through the <see cref="M:Parse.ParseQuery`1.GetAsync(System.String)"/> method. For example, this sample code
             fetches an object of class <c>"MyClass"</c> and id <c>myId</c>.
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             ParseObject result = await query.GetAsync(myId);
             </code>
            
             A ParseQuery can also be used to count the number of objects that match the
             query without retrieving all of those objects. For example, this sample code
             counts the number of objects of the class <c>"MyClass"</c>.
            
             <code>
             ParseQuery query = new ParseQuery("MyClass");
             int count = await query.CountAsync();
             </code>
             </example>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor(Parse.ParseQuery{`0},System.Collections.Generic.IDictionary{System.String,System.Object},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Nullable{System.Int32},System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Private constructor for composition of queries.  A source query is required,
            but the remaining values can be null if they won't be changed in this
            composition.
            </summary>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor">
            <summary>
            Constructs a query based upon the ParseObject subclass used as the generic parameter for the ParseQuery.
            </summary>
        </member>
        <member name="M:Parse.ParseQuery`1.#ctor(System.String)">
            <summary>
            Constructs a query. A default query with no further parameters will retrieve
            all <see cref="T:Parse.ParseObject"/>s of the provided class.
            </summary>
            <param name="className">The name of the class to retrieve ParseObjects for.</param>
        </member>
        <member name="M:Parse.ParseQuery`1.Or(System.Collections.Generic.IEnumerable{Parse.ParseQuery{`0}})">
            <summary>
            Constructs a query that is the or of the given queries.
            </summary>
            <param name="queries">The list of ParseQueries to 'or' together.</param>
            <returns>A ParseQquery that is the 'or' of the passed in queries.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.OrderBy(System.String)">
            <summary>
            Sorts the results in ascending order by the given key.
            This will override any existing ordering for the query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.OrderByDescending(System.String)">
            <summary>
            Sorts the results in descending order by the given key.
            This will override any existing ordering for the query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.ThenBy(System.String)">
            <summary>
            Sorts the results in ascending order by the given key, after previous
            ordering has been applied.
            
            This method can only be called if there is already an <see cref="M:Parse.ParseQuery`1.OrderBy(System.String)"/>
            or <see cref="M:Parse.ParseQuery`1.OrderByDescending(System.String)"/>
            on this query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.ThenByDescending(System.String)">
            <summary>
            Sorts the results in descending order by the given key, after previous
            ordering has been applied.
            
            This method can only be called if there is already an <see cref="M:Parse.ParseQuery`1.OrderBy(System.String)"/>
            or <see cref="M:Parse.ParseQuery`1.OrderByDescending(System.String)"/> on this query.
            </summary>
            <param name="key">The key to order by.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Include(System.String)">
            <summary>
            Include nested ParseObjects for the provided key. You can use dot notation
            to specify which fields in the included objects should also be fetched.
            </summary>
            <param name="key">The key that should be included.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Select(System.String)">
            <summary>
            Restrict the fields of returned ParseObjects to only include the provided key.
            If this is called multiple times, then all of the keys specified in each of
            the calls will be included.
            </summary>
            <param name="key">The key that should be included.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Skip(System.Int32)">
            <summary>
            Skips a number of results before returning.  This is useful for pagination
            of large queries.  Chaining multiple skips together will cause more results
            to be skipped.
            </summary>
            <param name="count">The number of results to skip.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.Limit(System.Int32)">
            <summary>
            Controls the maximum number of results that are returned.  Setting a negative
            limit denotes retrieval without a limit.  Chaining multiple limits
            results in the last limit specified being used. The default limit is
            100, with a maximum of 1000 results being returned at a time.
            </summary>
            <param name="count">The maximum number of results to return.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContainedIn``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            contained in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContainsAll``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Add a constraint to the querey that requires a particular key's value to be
            a list containing all of the elements in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereContains(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that contain a provided string.
            This will be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="substring">The substring that the value must contain.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotExist(System.String)">
            <summary>
            Adds a constraint for finding objects that do not contain a given key.
            </summary>
            <param name="key">The key that should not exist.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotMatchQuery``1(System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires that a particular key's value
            does not match another ParseQuery.  This only works on keys whose values are
            ParseObjects or lists of ParseObjects.
            </summary>
            <param name="key">The key to check.</param>
            <param name="query">The query that the value should not match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereEndsWith(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that end with a provided string.
            This will be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="suffix">The substring that the value must end with.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that the ParseObject must contain.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereExists(System.String)">
            <summary>
            Adds a constraint for finding objects that contain a given key.
            </summary>
            <param name="key">The key that should exist.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereGreaterThan(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            greater than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereGreaterThanOrEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            greater or equal to than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereLessThan(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            less than the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides an upper bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereLessThanOrEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            less than or equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that provides a lower bound.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.Text.RegularExpressions.Regex,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="regex">The regular expression pattern to match. The Regex must
            have the <see cref="F:System.Text.RegularExpressions.RegexOptions.ECMAScript"/> options flag set.</param>
            <param name="modifiers">Any of the following supported PCRE modifiers:
            <code>i</code> - Case insensitive search
            <code>m</code> Search across multiple lines of input</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="regex">The regular expression pattern to match. The Regex must
            have the <see cref="F:System.Text.RegularExpressions.RegexOptions.ECMAScript"/> options flag set.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.String,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="pattern">The PCRE regular expression pattern to match.</param>
            <param name="modifiers">Any of the following supported PCRE modifiers:
            <code>i</code> - Case insensitive search
            <code>m</code> Search across multiple lines of input</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatches(System.String,System.String)">
            <summary>
            Adds a regular expression constraint for finding string values that match the provided
            regular expression. This may be slow for large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="pattern">The PCRE regular expression pattern to match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatchesKeyInQuery``1(System.String,System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value
            to match a value for a key in the results of another ParseQuery.
            </summary>
            <param name="key">The key whose value is being checked.</param>
            <param name="keyInQuery">The key in the objects from the subquery to look in.</param>
            <param name="query">The subquery to run</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereDoesNotMatchesKeyInQuery``1(System.String,System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value
            does not match any value for a key in the results of another ParseQuery.
            </summary>
            <param name="key">The key whose value is being checked.</param>
            <param name="keyInQuery">The key in the objects from the subquery to look in.</param>
            <param name="query">The subquery to run</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereMatchesQuery``1(System.String,Parse.ParseQuery{``0})">
            <summary>
            Adds a constraint to the query that requires that a particular key's value
            matches another ParseQuery.  This only works on keys whose values are
            ParseObjects or lists of ParseObjects.
            </summary>
            <param name="key">The key to check.</param>
            <param name="query">The query that the value should match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNear(System.String,Parse.ParseGeoPoint)">
            <summary>
            Adds a proximity-based constraint for finding objects with keys whose GeoPoint
            values are near the given point.
            </summary>
            <param name="key">The key that the ParseGeoPoint is stored in.</param>
            <param name="point">The reference ParseGeoPoint.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNotContainedIn``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a constraint to the query that requires a particular key's value to be
            contained in the provided list of values.
            </summary>
            <param name="key">The key to check.</param>
            <param name="values">The values that will match.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereNotEqualTo(System.String,System.Object)">
            <summary>
            Adds a constraint to the query that requires a particular key's value not
            to be equal to the provided value.
            </summary>
            <param name="key">The key to check.</param>
            <param name="value">The value that that must not be equalled.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereStartsWith(System.String,System.String)">
            <summary>
            Adds a constraint for finding string values that start with the provided string.
            This query will use the backend index, so it will be fast even with large data sets.
            </summary>
            <param name="key">The key that the string to match is stored in.</param>
            <param name="suffix">The substring that the value must start with.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereWithinGeoBox(System.String,Parse.ParseGeoPoint,Parse.ParseGeoPoint)">
            <summary>
            Add a constraint to the query that requires a particular key's coordinates to be
            contained within a given rectangular geographic bounding box.
            </summary>
            <param name="key">The key to be constrained.</param>
            <param name="southwest">The lower-left inclusive corner of the box.</param>
            <param name="northeast">The upper-right inclusive corner of the box.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.WhereWithinDistance(System.String,Parse.ParseGeoPoint,Parse.ParseGeoDistance)">
            <summary>
            Adds a proximity-based constraint for finding objects with keys whose GeoPoint
            values are near the given point and within the maximum distance given.
            </summary>
            <param name="key">The key that the ParseGeoPoint is stored in.</param>
            <param name="point">The reference ParseGeoPoint.</param>
            <param name="maxDistance">The maximum distance (in radians) of results to return.</param>
            <returns>A new query with the additional constraint.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FindAsync">
            <summary>
            Retrieves a list of ParseObjects that satisfy this query from Parse.
            </summary>
            <returns>The list of ParseObjects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FindAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves a list of ParseObjects that satisfy this query from Parse.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The list of ParseObjects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstOrDefaultAsync">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <returns>A single ParseObject that satisfies this query, or else null.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstOrDefaultAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A single ParseObject that satisfies this query, or else null.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstAsync">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <returns>A single ParseObject that satisfies this query.</returns>
            <exception cref="T:Parse.ParseException">If no results match the query.</exception>
        </member>
        <member name="M:Parse.ParseQuery`1.FirstAsync(System.Threading.CancellationToken)">
            <summary>
            Retrieves at most one ParseObject that satisfies this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A single ParseObject that satisfies this query.</returns>
            <exception cref="T:Parse.ParseException">If no results match the query.</exception>
        </member>
        <member name="M:Parse.ParseQuery`1.CountAsync">
            <summary>
            Counts the number of objects that match this query.
            </summary>
            <returns>The number of objects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.CountAsync(System.Threading.CancellationToken)">
            <summary>
            Counts the number of objects that match this query.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The number of objects that match this query.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.GetAsync(System.String)">
            <summary>
            Constructs a ParseObject whose id is already known by fetching data
            from the server.
            </summary>
            <param name="objectId">ObjectId of the ParseObject to fetch.</param>
            <returns>The ParseObject for the given objectId.</returns>
        </member>
        <member name="M:Parse.ParseQuery`1.GetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Constructs a ParseObject whose id is already known by fetching data
            from the server.
            </summary>
            <param name="objectId">ObjectId of the ParseObject to fetch.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The ParseObject for the given objectId.</returns>
        </member>
        <member name="P:Parse.ParseQuery`1.JsonString">
            <summary>
            For debugging purposes.
            </summary>
        </member>
        <member name="T:Parse.ParseRelationBase">
            <summary>
            A common base class for ParseRelations.
            </summary>
        </member>
        <member name="M:Parse.ParseRelationBase.CreateRelation(Parse.ParseObject,System.String,System.String)">
            <summary>
            Produces the proper ParseRelation&lt;T&gt; instance for the given classname.
            </summary>
        </member>
        <member name="T:Parse.ParseRelation`1">
            <summary>
            Provides access to all of the children of a many-to-many relationship.  Each instance of
            ParseRelation is associated with a particular parent and key.
            </summary>
            <typeparam name="T">The type of the child objects.</typeparam>
        </member>
        <member name="M:Parse.ParseRelation`1.Add(`0)">
            <summary>
            Adds an object to this relation. The object must already have been saved.
            </summary>
            <param name="obj">The object to add.</param>
        </member>
        <member name="M:Parse.ParseRelation`1.Remove(`0)">
            <summary>
            Removes an object from this relation.  The object must already have been saved.
            </summary>
            <param name="obj">The object to remove.</param>
        </member>
        <member name="P:Parse.ParseRelation`1.Query">
            <summary>
            Gets a query that can be used to query the objects in this relation.
            </summary>
        </member>
        <member name="T:Parse.ParseRole">
            <summary>
            Represents a Role on the Parse server.  ParseRoles represent groupings
            of <see cref="T:Parse.ParseUser"/>s for the purposes of granting permissions (e.g.
            specifying a <see cref="T:Parse.ParseACL"/> for a <see cref="T:Parse.ParseObject"/>. Roles
            are specified by their sets of child users and child roles, all of which are granted
            any permissions that the parent role has.
            
            Roles must have a name (that cannot be changed after creation of the role),
            and must specify an ACL.
            </summary>
        </member>
        <member name="M:Parse.ParseRole.#ctor">
            <summary>
            Constructs a new ParseRole.  You must assign a name and ACL to the role.
            </summary>
        </member>
        <member name="M:Parse.ParseRole.#ctor(System.String,Parse.ParseACL)">
            <summary>
            Constructs a new ParseRole with the given name.
            </summary>
            <param name="name">The name of the role to create.</param>
            <param name="acl">The ACL for this role. Roles must have an ACL.</param>
        </member>
        <member name="P:Parse.ParseRole.Name">
            <summary>
            Gets the name of the role.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Users">
            <summary>
            Gets the <see cref="T:Parse.ParseRelation`1"/> for the <see cref="T:Parse.ParseUser"/>s that are
            direct children of this role. These users are granted any privileges that
            this role has been granted (e.g. read or write access through ACLs). You can
            add or remove child users from the role through this relation.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Roles">
            <summary>
            Gets the <see cref="T:Parse.ParseRelation`1"/> for the <see cref="T:Parse.ParseRole"/>s that are
            direct children of this role. These roles' users are granted any privileges that
            this role has been granted (e.g. read or write access through ACLs). You can
            add or remove child roles from the role through this relation.
            </summary>
        </member>
        <member name="P:Parse.ParseRole.Query">
            <summary>
            Gets a <see cref="T:Parse.ParseQuery`1"/> over the Role collection.
            </summary>
        </member>
        <member name="T:Parse.ParseSession">
            <summary>
            Represents a session of a user for a Parse application.
            </summary>
        </member>
        <member name="M:Parse.ParseSession.GetCurrentSessionAsync">
            <summary>
            Gets the current <see cref="T:Parse.ParseSession"/> object related to the current user.
            </summary>
        </member>
        <member name="M:Parse.ParseSession.GetCurrentSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the current <see cref="T:Parse.ParseSession"/> object related to the current user.
            </summary>
            <param name="cancellationToken">The cancellation token</param>
        </member>
        <member name="P:Parse.ParseSession.SessionToken">
            <summary>
            Gets the session token for a user, if they are logged in.
            </summary>
        </member>
        <member name="P:Parse.ParseSession.Query">
            <summary>
            Constructs a <see cref="T:Parse.ParseQuery`1"/> for ParseSession.
            </summary>
        </member>
        <member name="T:Parse.ParseUploadProgressEventArgs">
            <summary>
            Represents upload progress.
            </summary>
        </member>
        <member name="P:Parse.ParseUploadProgressEventArgs.Progress">
            <summary>
            Gets the progress (a number between 0.0 and 1.0) of an upload.
            </summary>
        </member>
        <member name="T:Parse.ParseUser">
            <summary>
            Represents a user for a Parse application.
            </summary>
        </member>
        <member name="F:Parse.ParseUser.currentUserMatchesDisk">
            <summary>
            Whether the currentUser is known to match the serialized version on disk.
            This is useful for saving a filesystem check if you try to load currentUser
            frequently while there is none on disk.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.#ctor">
            <summary>
            Constructs a new ParseUser with no data.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.Remove(System.String)">
            <summary>
            Removes a key from the object's data if it exists.
            </summary>
            <param name="key">The key to remove.</param>
            <exception cref="T:System.ArgumentException">Cannot remove the username key.</exception>
        </member>
        <member name="M:Parse.ParseUser.SignUpAsync">
            <summary>
            Signs up a new user. This will create a new ParseUser on the server and will also persist the
            session on disk so that you can access the user using <see cref="P:Parse.ParseUser.CurrentUser"/>. A username and
            password must be set before calling SignUpAsync.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.SignUpAsync(System.Threading.CancellationToken)">
            <summary>
            Signs up a new user. This will create a new ParseUser on the server and will also persist the
            session on disk so that you can access the user using <see cref="P:Parse.ParseUser.CurrentUser"/>. A username and
            password must be set before calling SignUpAsync.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseUser.LogInAsync(System.String,System.String)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="username">The username to log in with.</param>
            <param name="password">The password to log in with.</param>
            <returns>The newly logged-in user.</returns>
        </member>
        <member name="M:Parse.ParseUser.LogInAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="username">The username to log in with.</param>
            <param name="password">The password to log in with.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The newly logged-in user.</returns>
        </member>
        <member name="M:Parse.ParseUser.BecomeAsync(System.String)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="sessionToken">The session token to authorize with</param>
            <returns>The user if authorization was successful</returns>
        </member>
        <member name="M:Parse.ParseUser.BecomeAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Logs in a user with a username and password. On success, this saves the session to disk so you
            can retrieve the currently logged in user using <see cref="P:Parse.ParseUser.CurrentUser"/>.
            </summary>
            <param name="sessionToken">The session token to authorize with</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The user if authorization was successful</returns>
        </member>
        <member name="M:Parse.ParseUser.LogOut">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.LogOutAsync">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            
            This is preferable to using <see cref="M:Parse.ParseUser.LogOut"/>, unless your code is already running from a
            background thread.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.LogOutAsync(System.Threading.CancellationToken)">
            <summary>
            Logs out the currently logged in user session. This will remove the session from disk, log out of
            linked services, and future calls to <see cref="P:Parse.ParseUser.CurrentUser"/> will return <c>null</c>.
            
            This is preferable to using <see cref="M:Parse.ParseUser.LogOut"/>, unless your code is already running from a
            background thread.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.GetCurrentUserAsync">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary, asynchronously.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.GetCurrentUserAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary, asynchronously.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.EnableRevocableSessionAsync">
            <summary>
            Tells server to use revocable session on LogIn and SignUp, even when App's Settings
            has "Require Revocable Session" turned off. Issues network request in background to
            migrate the sessionToken on disk to revocable session.
            </summary>
            <returns>The Task that upgrades the session.</returns>
        </member>
        <member name="M:Parse.ParseUser.EnableRevocableSessionAsync(System.Threading.CancellationToken)">
            <summary>
            Tells server to use revocable session on LogIn and SignUp, even when App's Settings
            has "Require Revocable Session" turned off. Issues network request in background to
            migrate the sessionToken on disk to revocable session.
            </summary>
            <returns>The Task that upgrades the session.</returns>
        </member>
        <member name="M:Parse.ParseUser.RequestPasswordResetAsync(System.String)">
            <summary>
            Requests a password reset email to be sent to the specified email address associated with the
            user account.  This email allows the user to securely reset their password on the Parse site.
            </summary>
            <param name="email">The email address associated with the user that forgot their password.</param>
        </member>
        <member name="M:Parse.ParseUser.RequestPasswordResetAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Requests a password reset email to be sent to the specified email address associated with the
            user account.  This email allows the user to securely reset their password on the Parse site.
            </summary>
            <param name="email">The email address associated with the user that forgot their password.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Parse.ParseUser.CleanupAuthData">
            <summary>
            Removes null values from authData (which exist temporarily for unlinking)
            </summary>
        </member>
        <member name="M:Parse.ParseUser.SynchronizeAllAuthData">
            <summary>
            Synchronizes authData for all providers.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.UnlinkFromAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Unlinks a user from a service.
            </summary>
        </member>
        <member name="M:Parse.ParseUser.IsLinked(System.String)">
            <summary>
            Checks whether a user is linked to a service.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.IsAuthenticated">
            <summary>
            Whether the ParseUser has been authenticated on this device.  Only an authenticated
            ParseUser can be saved and deleted.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Username">
            <summary>
            Gets or sets the username.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Password">
            <summary>
            Sets the password.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Email">
            <summary>
            Sets the email address.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.CurrentUser">
            <summary>
            Gets the currently logged in ParseUser with a valid session, either from memory or disk
            if necessary.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.Query">
            <summary>
            Constructs a <see cref="T:Parse.ParseQuery`1"/> for ParseUsers.
            </summary>
        </member>
        <member name="P:Parse.ParseUser.AuthData">
            <summary>
            Gets the authData for this user.
            </summary>
        </member>
    </members>
</doc>
